---
title: "PhysReproDataPrep"
author: "Ashlee Mikkelsen"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This Rmarkdownd will go through data prep for analysis of the physiological indicators of reproduction in brown bears (*Ursus arctos arctos*) in Sweden

```{r, include=FALSE}
# clear workspace and load packages
rm(list = ls())
setwd("~/Rprojects/Diet-and-reproduction-in-rown-bears")

library(readxl)
library(dplyr)
library(ggplot2)
library(viridis)
library(tidyverse)

```

```{r load data, include=FALSE}

rawdata<- read_excel("RawBearData_SI_CORT.xlsx", 
    col_types = c("text", "text", "text", 
        "text", "text", "text", "text", 
        "text", "text", "text", "text", "text", 
        "text", "text", "text", "text", 
        "date", "text", "text", "text"))
str(rawdata)
warnings()

```

So I have my raw data loaded and it needs a lot of work to be usable for analysis. I need to correct the cortisol for the difference between extraction kits. I need to correct the 13C for the Suess effect, I need to extract the females from this files and I need to determine how many NAs are present and what to do with them. Do I remove them or do I populate their missing data?

### Data Cleanup
I need remove quantify the records with missing values. 149 females do not have cortisol values and of these, 35 are missing stable isotope data. For now, let's remove these.
```{r remove NAs}

bears.fem <- subset(rawdata, reprostatus.represent!="SolitaryM")
bears.fem.cort <- subset(bears.fem, cortisol!="NA")
bears.fem.cort.si <- subset(bears.fem.cort, N15!="NA")


```


I guess the first step will be correcting the cortisol. This means that I need to use the equation published in Wilson et al. 2021. While this analysis focuses on females, it also includes cubs-yearlings, which include males. Therefore the general cortisol correction is ideal

$$
cortisol from kit 2 = 1.65 + (0.98 * cortisol from kit 1)
$$

```{r isolate females and correct cortisol}

kit <- bears.fem.cort.si$cort.kit
print(kit)
cort.raw <- as.numeric(bears.fem.cort.si$cortisol)
cort.corrected <-as.numeric(rep(0,length(kit)))

df <-as.data.frame(cbind("kit"=kit, "cort.raw"=as.numeric(cort.raw), "cort.corrected"=as.numeric(cort.corrected)))
df$cort.raw <- as.numeric(df$cort.raw)
df$cort.corrected <- as.numeric(df$cort.corrected)

str(df)
print(df[2,2])


kit1correction <- function(x,y){
  y=1.65+(0.98*x)
}

kit2correction <- function(x,y){
  y=(x*1)
}

for (i in 1:length(df[,1])) {
  if(df[i,1]=="1"){
    df[i,3] <- kit1correction(df[i,2])
  } else {
    df[i,3] <- kit2correction(df[i,2])
  }
}

bears.fem.cort.si$cortisol.kitcorrected <- df$cort.corrected

```

The next step is to correct the 𝛅13C values for the Suess effect due to human burning of fossil fuels. Following Chamerlain *et al.* 2005, I use a time-dependent correction of -0.022‰ for each year up to the last year in my data set.

$$
13C_(Suess_) = 13C_(year_(_i_)) 
$$

```{r}

LastYr <- as.numeric(max(bears.fem.cort.si$year.represent))
bears.fem.cort.si$year.represent <- as.numeric(bears.fem.cort.si$year.represent)
bears.fem.cort.si$C13 <- as.numeric(bears.fem.cort.si$C13)

C13.suess <- bears.fem.cort.si$C13-(+0.022*(LastYr-bears.fem.cort.si$year.represent))
bears.fem.cort.si$C13.suess <- C13.suess


```


It looks like there are a few more housekeeping issues to address. A common metric of body condition is mass or mass scaled by a body measurement. In this case, we have mass and head circumference. I will create a body condition metric based on these two measurements

```{r}
bears.repro <- subset(bears.fem.cort.si, reprostatus.represent!="NA")
bears.repro$N15 <- as.numeric(bears.repro$N15)

bears.repro$weight <- as.numeric(bears.repro$weight)
bears.repro$headcirc <- as.numeric(bears.repro$headcirc)
bears.repro$condition <- bears.repro$weight/bears.repro$headcirc
# Bears will have a higher body condition index as the ratio between head circumference, which is a good measure of the overall skeletal size, and their mass increases. For example, a bear with really high mass and a small head means they are a smaller bear with greater fet reserves, muscle mass, or organs. All three of these equate to plentiful resource availability
```

Most of the data was stored as characters which is really annoying. There is a better way to do this, but I am just going to go through and fix most of these right now
```{r}
bears.repro$fYEAR <- bears.repro$year.represent
bears.repro$year.represent <- as.numeric(bears.repro$year.represent)
bears.repro$age <- as.numeric(bears.repro$age)
bears.repro$fAGE <- as.factor(bears.repro$age)
bears.repro$weight <- as.numeric(bears.repro$weight)




```



```{r}
bear.reprodata <- bears.repro %>%
  rename(
    repro=reprostatus.represent,
    year=year.represent,
    bearyear=bearyear.represent,
    mass=weight
  )
```




```{r}
bear.reprodata$Cmonth<-as.numeric(format(bear.reprodata$capturedate,"%m"))
ggplot(data = bear.reprodata, aes(Cmonth))+
  geom_bar()
# Need to remove bears captured after june
bear.reprodata.capture <- subset(bear.reprodata, Cmonth<7)
ggplot(data = bear.reprodata.capture, aes(Cmonth))+
  geom_bar()

```


### Reproduction covariates

Now that I have my data cleaned up and I have identified the females for which we have stable isotopes and cortisol, I need to extract and summarize their reproductive status, length of meternal care, etc for analysis.

First off, I load in the reproduction data table given to me by Jenny Hansen on 25 April 2022

```{r}
ReproData <- read.csv("ReproData20220425.csv")
str(ReproData)


# Ok. Below I pull out all the unique bear IDs in my dataset
BearIDs <- bear.reprodata.capture %>% count(BearID)

# Next I need to pull all the records for the bears in my dataset

ReproID <- ReproData$objectid

BID <- BearIDs$BearID

d.f <- ReproData[ReproData$objectid %in% BID,]

d.f %>% count(objectid)
```


Now I want to only include the bear years included in my data base. Then I concentrate bear and year to make a string that matches the bearyear.sampled in the bear.reprodata.capture table and will pull out the records that match.

It is important to remember that bears are captured when their cubs are yearlings. So using Öda as an example, she was captured in 2000,2002,2004,2006,and 2008. In each of these instances she had cubs that were 1 year old, meaning that the stable isotopes and cortisol values represent the year when her cubs were cubs of the year. 


```{r}
d.f$Bear.Year <- paste0(d.f$objectid,"_",d.f$year)

DF.BearYear <- d.f[d.f$Bear.Year %in% bear.reprodata.capture$bearyear.sampled,]

# Somehow the records in bear.repro.capture table do not match the DF.BearYear table. There is a discrepency of 3 records

Count1 <- DF.BearYear %>% count(objectid)
Count2 <- bear.reprodata.capture %>% count(BearID)

COUNT <- cbind(Count1,Count2)

for (i in 1:305) {
  if(COUNT[i,2]==COUNT[i,4]){
    print("Good")
  } else{
    print(COUNT[i,1])
  }
}
# Now I can see which records do not match: W0402, W0610, and W9812.All three of these are instances in which there are two records for the same bear in the same year. 


DF.brc <- bear.reprodata.capture %>%
  group_by(bearyear.sampled) %>%
  summarise(
    BearID=BearID,
    year=year,
    bearyear.sampled=bearyear.sampled,
    sex=sex,
    birth=birth,
    age=age,
    repro=repro,
    mN15=mean(N15),
    mC13=mean(C13.suess),
    mass=mass,
    headcirc=headcirc,
    capturedate=capturedate,
    cortisol.kitcorrected=mean(cortisol.kitcorrected),
    condition=condition,
    fYEAR=fYEAR,
    fAGE=fAGE
  )
# Now I have taken the mean stable isotope value and cortisol value for those three records, but now there are duplicates. So I need to delete one of the duplicates.

DF.brc2 <- DF.brc[-c(127,203,524),]

# Now I should be able to combine the data from the repro table and the bear data table

names(DF.brc2)[names(DF.brc2)=="bearyear.sampled"] <- "Bear.Year"
names(DF.brc2)[names(DF.brc2)=="year"] <- "Year.rep"

BRC <- merge(DF.brc2, DF.BearYear, by="Bear.Year")
```




Now my data frame has several columns with duplicate infor and confusing names, so I will subset it to minimize redundancy and then rename the columns to make them more interpretable.

```{r}

BRC.reduced <- subset(BRC, select=-c(sex.y,Nr,objectid,comment,ACT,Temp,HR,OBS,Milk,Tracks,X,X.1))


BRC.rename <- BRC.reduced %>%
  rename(
    bear.year=Bear.Year,
    bearID=BearID,
    year.rep=Year.rep,
    sex=sex.x,
    birth.year=birth,
    dN15=mN15,
    dC13=mC13,
    fREPRO=FiNAl_reproduction_status_winter.spring,
    number.cubs=numberofcubsfirstcount,
    cub.age=cubage,
    capture.date=capturedate,
    pub.name=pubname
  )


```



Finally, we save our datafile

```{r}

write.csv(BRC.rename,"bearreprodata.csv")

rm(list = setdiff(ls(), "BRC.rename"))

library(dplyr)

```


I need to make a family group covariate, but because of the way this data is formatted, it's very frustrating


```{r}


#OK. So at this point i need to loop through the offspring and if they have the same mom as MBY [i,1] and same year as MBY [i,2], they get the family group of MBY [i,3]. I also need a loop to loop through all of the records in Offspring

Mams <- vector()
ReproEvents <- vector()
for (i in 1:557) {
  if(BRC.rename[i,7]=="WithCubs"){
    Mams[i]=BRC.rename[i,36]
  }else{Mams[i]=0}
}

for (i in 1:557) {
  if(BRC.rename[i,7]=="WithCubs"){
    ReproEvents[i]=BRC.rename[i,3]
  }
}

Reproduction <- as.data.frame(cbind(Mams,ReproEvents))
Reproduction.unique <- unique(Reproduction)
Reproduction.u.Nans <- subset(Reproduction.unique,Mams!="NA")
Reproduction.u.Nans.unknows <- subset(Reproduction.u.Nans,Mams!="unknown")

Clean.ReproductionEvents <- Reproduction.u.Nans.unknows






```

